// Energy Calculation in DMC (Drift Forces and Symmetry)
// In the drift force calculations (Fqa_x, Fqa_y, etc.), itâ€™s essential that the force applied between particle pairs is symmetric and correctly computed for each pair. The Lennard-Jones potential should be used correctly to calculate inter-particle distances and the resulting forces.

// Fix:
// Ensure that the distance r between two particles is consistently used for both particles. Currently, the force is calculated between particle k and particle l inside the loop, but you need to make sure that this is symmetric and properly handles all pairs:
// for (k = 1; k <= 3; k++) {
//   Fqa_x[k] = 0;
//   Fqa_y[k] = 0;
//   for (l = 1; l <= 3; l++) {
//     if (l != k) {
//       double r_kl = sqrt(pow((x_a[k] - x_a[l]), 2) + pow((y_a[k] - y_a[l]), 2)); // distance
//       double f_kl = -2 * f_dr(r_kl);  // force magnitude based on distance

//       Fqa_x[k] += f_kl * (x_a[k] - x_a[l]);  // force in x-direction
//       Fqa_y[k] += f_kl * (y_a[k] - y_a[l]);  // force in y-direction
//     }
//   }
// }

// Ensure that the same logic is applied for the Fqb_x and Fqb_y steps.

// Statistical Weight Calculation (W_Rpw)
// The W_Rpw weight calculation currently suffers from two main issues: potential numerical instability and incorrect random number handling. To fix this, you'll want to:
// Fix:
// Safeguard the exponential calculation to prevent overflow or underflow. You can set reasonable limits on the argument of the exponential (e.g., ensure that -(0.5 * (E_L[iw] + E_L_prime) - E_R) * dtau is within a safe range).
// double deltaE = 0.5 * (E_L[iw] + E_L_prime) - E_R;
// if (deltaE * dtau > MAX_EXP) {
//   deltaE = MAX_EXP / dtau;  // Limit the deltaE to prevent overflow
// } else if (deltaE * dtau < MIN_EXP) {
//   deltaE = MIN_EXP / dtau;  // Limit the deltaE to prevent underflow
// }
// W_Rpw[iw-1].value = exp(-deltaE * dtau);

// Adjust how rand_num is integrated into the weight calculation. Right now, rand_num is added directly to the weight, which seems problematic. Instead, use rand_num to adjust walker duplication with more control:
// n_w[iw] = (int)(W_Rpw[iw-1].value + rand_num);  // Ensure rand_num is between 0 and 1
// if (n_w[iw] < 0) {
//     n_w[iw] = 0; // Make sure you don't end up with negative walker counts
// }

